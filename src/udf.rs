/* udf.rs
   File generated by the "User" based on vision, with limited knowledge about the other parts of the framework

        Knowledge needed:
        1) UserDefinedFunction trait and how to implement it
        2) vertex's apply_function() function and their invoking protocols

   Author: Binghong(Leo) Li
   Creation Date: 1/14/2023
*/

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::ops::AddAssign;

use crate::graph::*;
use crate::vertex::*;
use crate::UserDefinedFunction;

/* *********** Starting of User's Playground *********** */

// Summing the entire graph

/*
   Data<isize> operations
*/
impl AddAssign<isize> for Data<isize> {
    fn add_assign(&mut self, other: isize) {
        self.0 += other;
    }
}

// UDF Struct
pub struct GraphSum;
#[async_trait]
impl UserDefinedFunction<isize, Option<u64>> for GraphSum {
    async fn execute(
        &self,
        vertex: &Vertex<isize>,
        graph: &Graph<isize, Option<u64>>,
        aux_info: Option<u64>,
    ) -> isize {
        let mut count = Data(0);
        count += vertex.get_val().as_ref().unwrap().0;

        for sub_graph_root_id in vertex.children().iter() {
            count += graph
                .get(sub_graph_root_id)
                .apply_function(self, graph, aux_info.clone())
                .await;
        }
        count.0
    }
}

/*
   Graph Sum in a Fusion Manner
       1) the nodes at the bounds are accessed by b
*/

pub struct NaiveMaxAdjacentSum;
// summing the most recent X nodes

// TODO: Check IMPL

#[derive(Serialize, Deserialize, Debug)]
pub enum Direction {
    Parent,
    Children,
    Start,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NMASInfo {
    pub direction: Direction,
    pub distance: usize,
    pub started: HashSet<VertexID>,
}
#[async_trait]
impl UserDefinedFunction<isize, Option<NMASInfo>> for NaiveMaxAdjacentSum {
    async fn execute(
        &self,
        vertex: &Vertex<isize>,
        graph: &Graph<isize, Option<NMASInfo>>,
        aux_info: Option<NMASInfo>,
    ) -> isize {
        let mut count = Data(0);
        count += vertex.get_val().as_ref().unwrap().0;

        let mut aux_info = aux_info.unwrap();

        if aux_info.distance == 0 {
            return count.0;
        }

        match aux_info.direction {
            Direction::Parent => {
                for parent_id in vertex.parents() {
                    count += graph
                        .get(parent_id)
                        .apply_function(
                            self,
                            graph,
                            Some(NMASInfo {
                                direction: Direction::Parent,
                                distance: aux_info.distance - 1,
                                started: aux_info.started.clone(),
                            }),
                        )
                        .await;
                }
            }
            Direction::Children => {
                for child_id in vertex.children() {
                    count += graph
                        .get(child_id)
                        .apply_function(
                            self,
                            graph,
                            Some(NMASInfo {
                                direction: Direction::Children,
                                distance: aux_info.distance - 1,
                                started: aux_info.started.clone(),
                            }),
                        )
                        .await;
                }
            }
            Direction::Start => {
                aux_info.started.insert(vertex.id);
                for child_id in vertex.children() {
                    count += graph
                        .get(child_id)
                        .apply_function(
                            self,
                            graph,
                            Some(NMASInfo {
                                direction: Direction::Children,
                                distance: aux_info.distance - 1,
                                started: aux_info.started.clone(),
                            }),
                        )
                        .await;
                }
                for parent_id in vertex.parents() {
                    count += graph
                        .get(parent_id)
                        .apply_function(
                            self,
                            graph,
                            Some(NMASInfo {
                                direction: Direction::Parent,
                                distance: aux_info.distance - 1,
                                started: aux_info.started.clone(),
                            }),
                        )
                        .await;
                }

                let res = count.0;
                let mut vec_of_res = vec![res];

                for connected_nodes_id in vertex.children().iter().chain(vertex.parents().iter()) {
                    if !aux_info.started.contains(connected_nodes_id) {
                        vec_of_res.push(
                            graph
                                .get(connected_nodes_id)
                                .apply_function(
                                    self,
                                    graph,
                                    Some(NMASInfo {
                                        direction: Direction::Start,
                                        distance: aux_info.distance,
                                        started: aux_info.started.clone(),
                                    }),
                                )
                                .await,
                        );
                    }
                }

                return vec_of_res.iter().max().unwrap().clone();
            }
        }

        count.0
    }
}

pub struct MaxBlockSum;
