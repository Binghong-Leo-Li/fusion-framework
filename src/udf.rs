/* udf.rs

   File generated by the "User" based on vision, with limited knowledge about the other parts of the framework

        Knowledge needed:
        1) UserDefinedFunction trait and how to implement it
        2) vertex's apply_function() function and their invoking protocols

   Author: Binghong(Leo) Li
   Creation Date: 1/14/2024
*/

use crate::datastore::DataStore;
use crate::vertex::*;
use crate::UserDefinedFunction;

use async_trait::async_trait;
use hashbrown::HashSet;
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};
use std::ops::AddAssign;

/* *********** Starting of User's Playground *********** */

/*
   Data<isize> operations
*/
impl AddAssign<isize> for Data<isize> {
    fn add_assign(&mut self, other: isize) {
        self.0 += other;
    }
}

// UDF Structs

/*
   GraphSum sums the entire graph recursively
*/
#[derive(Clone)]
pub struct GraphSum;
#[async_trait]
impl UserDefinedFunction<isize, Option<u64>, isize> for GraphSum {
    async fn execute(
        &self,
        vertex: &Vertex<isize, isize>,
        data_store: &DataStore<isize, isize>,
        aux_info: Option<u64>,
    ) -> isize {
        let mut count = Data(0);
        count += (*vertex.get_val().await).as_ref().unwrap().0;

        for sub_graph_root_id in vertex.children().iter() {
            count += data_store
                .get_vertex_by_id(sub_graph_root_id)
                .apply_function(self, data_store, aux_info.clone())
                .await;
        }
        count.0
    }
}

/*
   NaiveMaxAdjacentSum sums the most recent X nodes' data in a naive manner,
   restarting at each node at taking the max of all possible node starts
*/
#[derive(Clone)]
pub struct NaiveMaxAdjacentSum;

/*
   User defined auxiliary information to be passed around for each function call
*/
#[derive(Serialize, Deserialize)]
pub struct NMASInfo {
    pub source: Option<VertexID>, // if at the start then None, else encapsulates the start of the current exploration
    pub distance: usize,          // the steps the current node can use
    pub started: Option<HashSet<VertexID>>, // node that have been used as the start
}

#[async_trait]
impl UserDefinedFunction<isize, Option<NMASInfo>, isize> for NaiveMaxAdjacentSum {
    async fn execute(
        &self,
        vertex: &Vertex<isize, isize>,
        data_store: &DataStore<isize, isize>,
        aux_info: Option<NMASInfo>,
    ) -> isize {
        let mut count = Data(0);
        count += (*vertex.get_val().await).as_ref().unwrap().0;

        let aux_info = aux_info.unwrap();

        // exhausted all steps
        if aux_info.distance == 0 {
            return count.0;
        }

        return match &aux_info.source {
            None => {
                // this is start, add to the "started" set
                let mut aux_info_started = aux_info.started.unwrap();
                aux_info_started.insert(vertex.id);

                // travel to neighbors with distance - 1, "started" no longer needed
                for neighbor_id in vertex.edges() {
                    count += data_store
                        .get_vertex_by_id(neighbor_id)
                        .apply_function(
                            self,
                            data_store,
                            Some(NMASInfo {
                                source: Some(vertex.id),
                                distance: aux_info.distance - 1,
                                started: None,
                            }),
                        )
                        .await;
                }

                // gather all possible exploration results and taking the max
                let res = count.0;
                let mut vec_of_res = vec![res];

                // start all adjacent, non-"started" nodes
                for connected_nodes_id in vertex.edges().iter() {
                    if !aux_info_started.contains(connected_nodes_id) {
                        vec_of_res.push(
                            data_store
                                .get_vertex_by_id(connected_nodes_id)
                                .apply_function(
                                    self,
                                    data_store,
                                    Some(NMASInfo {
                                        source: None,
                                        distance: aux_info.distance,
                                        started: Some(aux_info_started.clone()),
                                    }),
                                )
                                .await,
                        );
                    }
                }

                // return the max of all explorations
                vec_of_res.iter().max().unwrap().clone()
            }
            Some(source) => {
                // This is not the start, travel to neighbors with distance - 1, "started" not needed
                for neighbor_id in vertex.edges() {
                    if source.ne(neighbor_id) {
                        count += data_store
                            .get_vertex_by_id(neighbor_id)
                            .apply_function(
                                self,
                                data_store,
                                Some(NMASInfo {
                                    source: Some(vertex.id),
                                    distance: aux_info.distance - 1,
                                    started: None,
                                }),
                            )
                            .await;
                    }
                }
                // return sum
                count.0
            }
        };
    }
}

// the following are still rough ideas

/*
   Graph Sum in a Fusion Manner
       1) the nodes at the bounds are accessed by both nodes
       2) When fused, the boundaries are taken care of

   This is for passing node data and "borrowing", where both nodes' data are needed
*/
pub struct GraphSumFusion;

/*
   Assuming that we have divided the graph into useful blocks, return the max-sum

   Also for borrowing
*/
pub struct MaxBlockSum;

/*
   Other brainstorms:
       1) update the node where the max exploration NaiveMaxAdjacentSum started from with the result
       2) update all nodes with plus 1
       3) swap largest and smallest nodes
       ...
*/

#[derive(Clone)]
pub struct SwapLargestAndSmallest;

#[derive(Serialize, Default, Deserialize, Debug)]
pub struct SLASInfo {
    pub max_val: Data<isize>,
    pub min_val: Data<isize>,
    pub max_id: VertexID,
    pub min_id: VertexID,
}

impl<T: DeserializeOwned + Ord + Default> PartialEq for Data<T> {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl<T: DeserializeOwned + Ord + Default> Eq for Data<T> {}
impl<T: DeserializeOwned + Ord + Default> PartialOrd for Data<T> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}
impl<T: DeserializeOwned + Ord + Default> Ord for Data<T> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.0.cmp(&other.0)
    }
}

#[async_trait]
impl UserDefinedFunction<isize, bool, SLASInfo> for SwapLargestAndSmallest {
    async fn execute(
        &self,
        vertex: &Vertex<isize, SLASInfo>,
        data_store: &DataStore<isize, SLASInfo>,
        aux_info: bool,
    ) -> SLASInfo {
        let val = vertex.get_val().await;
        println!("\n{:?}\n", vertex);

        if vertex.children().is_empty() {
            // I am the leaf
            return SLASInfo {
                max_val: (*val).clone().unwrap(),
                min_val: (*val).clone().unwrap(),
                max_id: vertex.id,
                min_id: vertex.id,
            };
        }
        let mut results = vec![];
        for children_id in vertex.children().iter() {
            let result = data_store
                .get_vertex_by_id(children_id)
                .apply_function(self, data_store, false)
                .await;
            results.push(result);
        }

        let mut res = SLASInfo {
            max_val: (*val).clone().unwrap(),
            min_val: (*val).clone().unwrap(),
            max_id: vertex.id,
            min_id: vertex.id,
        };

        for result in results.into_iter() {
            if result.max_val > res.max_val {
                res.max_val = result.max_val;
                res.max_id = result.max_id;
            }
            if result.min_val < res.min_val {
                res.min_val = result.min_val;
                res.min_id = result.min_id
            }
        }

        println!("\n{:?}\n", vertex);

        // not the root
        if !aux_info {
            return res;
        }

        // also send out the command to update the nodes' values

        let SLASInfo {
            max_val,
            max_id,
            min_val,
            min_id,
        } = &res;

        println!(
            "update1: {:?}",
            data_store
                .get_vertex_by_id(max_id)
                .update(min_val.clone())
                .await
        );
        println!(
            "update2: {:?}",
            data_store
                .get_vertex_by_id(min_id)
                .update(max_val.clone())
                .await
        );

        return res;
    }
}
