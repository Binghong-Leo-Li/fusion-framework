/* udf.rs
   File generated by the "User" based on vision, with limited knowledge about the other parts of the framework

        Knowledge needed:
        1) UserDefinedFunction trait and how to implement it
        2) vertex's apply_function() function and their invoking protocols

   Author: Binghong(Leo) Li
   Creation Date: 1/14/2023
*/

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::ops::AddAssign;

use crate::graph::*;
use crate::vertex::*;
use crate::UserDefinedFunction;

/* *********** Starting of User's Playground *********** */

// Summing the entire graph

/*
   Data<isize> operations
*/
impl AddAssign<isize> for Data<isize> {
    fn add_assign(&mut self, other: isize) {
        self.0 += other;
    }
}

// UDF Struct
#[derive(Clone)]
pub struct GraphSum;
#[async_trait]
impl UserDefinedFunction<isize, Option<u64>> for GraphSum {
    async fn execute(
        &self,
        vertex: &Vertex<isize>,
        graph: &Graph<isize, Option<u64>>,
        aux_info: Option<u64>,
    ) -> isize {
        let mut count = Data(0);
        count += vertex.get_val().as_ref().unwrap().0;

        for sub_graph_root_id in vertex.children().iter() {
            count += graph
                .get(sub_graph_root_id)
                .apply_function(self, graph, aux_info.clone())
                .await;
        }
        count.0
    }
}

/*
   Graph Sum in a Fusion Manner
       1) the nodes at the bounds are accessed by b
*/

#[derive(Clone)]
pub struct NaiveMaxAdjacentSum;
// summing the most recent X nodes

// TODO: Check IMPL

#[derive(Serialize, Deserialize, Debug)]
pub enum Direction {
    Parent,
    Children,
    Start,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NMASInfo {
    pub source: Option<VertexID>,
    pub distance: usize,
    pub started: Option<HashSet<VertexID>>,
}
#[async_trait]
impl UserDefinedFunction<isize, Option<NMASInfo>> for NaiveMaxAdjacentSum {
    async fn execute(
        &self,
        vertex: &Vertex<isize>,
        graph: &Graph<isize, Option<NMASInfo>>,
        aux_info: Option<NMASInfo>,
    ) -> isize {
        let mut count = Data(0);
        count += vertex.get_val().as_ref().unwrap().0;

        let mut aux_info = aux_info.unwrap();

        if aux_info.distance == 0 {
            return count.0;
        }

        return match &aux_info.source {
            None => {
                let mut aux_info_started = aux_info.started.unwrap();
                aux_info_started.insert(vertex.id);

                for neighbor_id in vertex.edges() {
                    count += graph
                        .get(neighbor_id)
                        .apply_function(
                            self,
                            graph,
                            Some(NMASInfo {
                                source: Some(vertex.id),
                                distance: aux_info.distance - 1,
                                started: None,
                            }),
                        )
                        .await;
                }

                let res = count.0;
                let mut vec_of_res = vec![res];

                for connected_nodes_id in vertex.edges().iter() {
                    if !aux_info_started.contains(connected_nodes_id) {
                        vec_of_res.push(
                            graph
                                .get(connected_nodes_id)
                                .apply_function(
                                    self,
                                    graph,
                                    Some(NMASInfo {
                                        source: None,
                                        distance: aux_info.distance,
                                        started: Some(aux_info_started.clone()),
                                    }),
                                )
                                .await,
                        );
                    }
                }

                return vec_of_res.iter().max().unwrap().clone();
            }
            Some(source) => {
                for neighbor_id in vertex.edges() {
                    if source.ne(neighbor_id) {
                        count += graph
                            .get(neighbor_id)
                            .apply_function(
                                self,
                                graph,
                                Some(NMASInfo {
                                    source: Some(vertex.id),
                                    distance: aux_info.distance - 1,
                                    started: None,
                                }),
                            )
                            .await;
                    }
                }
                count.0
            }
        };
    }
}

pub struct MaxBlockSum;
