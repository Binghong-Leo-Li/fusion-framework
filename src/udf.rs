/* udf.rs
   File generated by the "User" based on vision, with limited knowledge about the other parts of the framework

        Knowledge needed:
        1) UserDefinedFunction trait and how to implement it
        2) vertex's apply_function() function and their invoking protocols

   Author: Binghong(Leo) Li
   Creation Date: 1/14/2023
*/

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::ops::AddAssign;

use crate::vertex::*;
use crate::worker::*;
use crate::UserDefinedFunction;

/* *********** Starting of User's Playground *********** */

/*
   Data<isize> operations
*/
impl AddAssign<isize> for Data<isize> {
    fn add_assign(&mut self, other: isize) {
        self.0 += other;
    }
}

// UDF Structs

/*
   GraphSum sums the entire graph recursively
*/
#[derive(Clone)]
pub struct GraphSum;
#[async_trait]
impl UserDefinedFunction<isize, Option<u64>, isize> for GraphSum {
    async fn execute(
        &self,
        vertex: &Vertex<isize>,
        worker: &Worker<isize, isize>,
        aux_info: Option<u64>,
    ) -> isize {
        let mut count = Data(0);
        count += vertex.get_val().as_ref().unwrap().0;

        for sub_graph_root_id in vertex.children().iter() {
            count += worker
                .graph
                .read()
                .await
                .get(sub_graph_root_id) // TODO: need to abstract away this
                .unwrap()
                .read()
                .await
                .apply_function(self, worker, aux_info.clone())
                .await;
        }
        count.0
    }
}

/*
   NaiveMaxAdjacentSum sums the most recent X nodes' data in a naive manner,
   restarting at each node at taking the max of all possible node starts
*/
#[derive(Clone)]
pub struct NaiveMaxAdjacentSum;

/*
   User defined auxiliary information to be passed around for each function call
*/
#[derive(Serialize, Deserialize, Debug)]
pub struct NMASInfo {
    pub source: Option<VertexID>, // if at the start then None, else encapsulates the start of the current exploration
    pub distance: usize,          // the steps the current node can use
    pub started: Option<HashSet<VertexID>>, // node that have been used as the start
}

#[async_trait]
impl UserDefinedFunction<isize, Option<NMASInfo>, isize> for NaiveMaxAdjacentSum {
    async fn execute(
        &self,
        vertex: &Vertex<isize>,
        worker: &Worker<isize, isize>,
        aux_info: Option<NMASInfo>,
    ) -> isize {
        let mut count = Data(0);
        count += vertex.get_val().as_ref().unwrap().0;

        let aux_info = aux_info.unwrap();

        // exhausted all steps
        if aux_info.distance == 0 {
            return count.0;
        }

        return match &aux_info.source {
            None => {
                // this is start, add to the "started" set
                let mut aux_info_started = aux_info.started.unwrap();
                aux_info_started.insert(vertex.id);

                // travel to neighbors with distance - 1, "started" no longer needed
                for neighbor_id in vertex.edges() {
                    // worker.vertices[id].function_name()

                    count += worker
                        .graph
                        .read()
                        .await
                        .get(neighbor_id) // TODO: need to abstract away this
                        .unwrap()
                        .read()
                        .await
                        .apply_function(
                            self,
                            worker,
                            Some(NMASInfo {
                                source: Some(vertex.id),
                                distance: aux_info.distance - 1,
                                started: None,
                            }),
                        )
                        .await;
                }

                // gather all possible exploration results and taking the max
                let res = count.0;
                let mut vec_of_res = vec![res];

                // start all adjacent, non-"started" nodes
                for connected_nodes_id in vertex.edges().iter() {
                    if !aux_info_started.contains(connected_nodes_id) {
                        vec_of_res.push(
                            worker
                                .graph
                                .read()
                                .await
                                .get(connected_nodes_id) // TODO: need to abstract away this
                                .unwrap()
                                .read()
                                .await
                                .apply_function(
                                    self,
                                    worker,
                                    Some(NMASInfo {
                                        source: None,
                                        distance: aux_info.distance,
                                        started: Some(aux_info_started.clone()),
                                    }),
                                )
                                .await,
                        );
                    }
                }

                // return the max of all explorations
                vec_of_res.iter().max().unwrap().clone()
            }
            Some(source) => {
                // This is not the start, travel to neighbors with distance - 1, "started" not needed
                for neighbor_id in vertex.edges() {
                    if source.ne(neighbor_id) {
                        count += worker
                            .graph
                            .read()
                            .await
                            .get(neighbor_id) // TODO: need to abstract away this
                            .unwrap()
                            .read()
                            .await
                            .apply_function(
                                self,
                                worker,
                                Some(NMASInfo {
                                    source: Some(vertex.id),
                                    distance: aux_info.distance - 1,
                                    started: None,
                                }),
                            )
                            .await;
                    }
                }
                // return sum
                count.0
            }
        };
    }
}

// the following are still rough ideas

/*
   Graph Sum in a Fusion Manner
       1) the nodes at the bounds are accessed by both nodes
       2) When fused, the boundaries are taken care of

   This is for passing node data and "borrowing", where both nodes' data are needed
*/
pub struct GraphSumFusion;

/*
   Assuming that we have divided the graph into useful blocks, return the max-sum

   Also for borrowing
*/
pub struct MaxBlockSum;

/*
   Other brainstorms:
       1) update the node where the max exploration NaiveMaxAdjacentSum started from with the result
       2) update all nodes with plus 1
       3) swap largest and smallest nodes
       ...
*/

pub struct PropagateParent;

#[async_trait]
impl UserDefinedFunction<isize, Option<u64>, bool> for PropagateParent {
    async fn execute(
        &self,
        vertex: &Vertex<isize>,
        worker: &Worker<isize, bool>,
        aux_info: Option<u64>,
    ) -> bool {
        match aux_info {
            None => return true,
            Some(to_add) => vertex.update(),
        }
        for child_id in vertex.children() {
            worker
                .graph
                .read()
                .await
                .get(child_id)
                .unwrap()
                .write()
                .await
                .apply_function()
        }
        return true;
    }
}
